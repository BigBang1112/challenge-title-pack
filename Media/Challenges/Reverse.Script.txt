***Metadata***
***
Script.Name = "Reverse";
Script.AuthorLogin = "bigbang1112";
Script.Description = "{{{{REVERSE_DESCRIPTION}}}}";
***

***Main***
***
declare StartLines = GetStartLines();
declare Multilaps = GetMultilaps();
declare FinishLines = GetFinishLines();
declare MapInfo = GetMapInfo();
declare Environment = MapInfo.CollectionName;

declare IsOneLapWithFinish = Multilaps.count == 1 && FinishLines.count > 0 && MapInfo.TMObjective_NbLaps == 1;
declare IsMultilap = Multilaps.count == 1 && !IsOneLapWithFinish;

if(IsMultilap) {
	declare SChProblem Problem_MultilapTrack;
	Problem_MultilapTrack.Name = "MULTILAP_TRACK";
	Problem_MultilapTrack.Waypoint = Multilaps[0];
	Problem_MultilapTrack.ShortDescription = "{{{{MULTILAP_TRACK}}}}";
	Problem_MultilapTrack.LongDescription = "This track has a multilap which isn't considered as one lap with 1 or more finishes. This map can't be reversed.";
	Problem(Problem_MultilapTrack);
}

if(FinishLines.count > 1) {
	declare SChProblem Problem_MultipleFinishes;
	Problem_MultipleFinishes.Name = "MULTILAP_TRACK";
	Problem_MultipleFinishes.Waypoints = FinishLines;
	Problem_MultipleFinishes.ShortDescription = "{{{{MULTIPLE_FINISHES}}}}";
	Problem_MultipleFinishes.LongDescription = "This track has multiple finishes. Script is not able to automate the finish replacement process.";
	Problem_MultipleFinishes.Solutions.add("Delete the finish you want to replace with its start variant.");
	Problem(Problem_MultipleFinishes);
}

if(IsOneLapWithFinish) {
	declare Multilap = Multilaps[0];
	if(Multilap.IsItem) {
		declare SChProblem Problem_ItemMultilap;
		Problem_ItemMultilap.Name = "ITEM_MULTILAP";
		Problem_ItemMultilap.Waypoint = Multilap;
		Problem_ItemMultilap.ShortDescription = "{{{{CANNOT_REPLACE_MULTILAP}}}}";
		Problem_ItemMultilap.LongDescription = "Multilap is an item. Script can't replace those.";
		Problem_ItemMultilap.Solutions.add("Replace the multilap item manually with a possible finish variant.");
		Problem(Problem_ItemMultilap);
	}
	else if(Multilap.IsBlock) {
		foreach(Relation, Relation_MultilapFinishTwoway[Environment]) {
			declare MultilapBlockName = Relation[0];
			declare FinishTwowayBlockName = Relation[1];
			if(Multilap.Block.Name == MultilapBlockName) {
				declare Removed = RemoveSpecificBlock(Multilap.Block);
				if(Removed) {
					if(IsSpecialBlock(FinishTwowayBlockName)) {
						declare Block = PlaceBlock(FinishTwowayBlockName, Multilap.Block.Coord, Multilap.Block.Direction);
						if(Block.Placed)
							SetStatusMessage(MultilapBlockName ^ " {{{{replaced_with}}}} " ^ FinishTwowayBlockName ^ ".");
						else {
							declare SChProblem Problem_BlockMissing;
							Problem_BlockMissing.Name = "BLOCK_MISSING";
							Problem_BlockMissing.BlockName = FinishTwowayBlockName;
							Problem_BlockMissing.ShortDescription = "{{{{BLOCK_MISSING}}}} - " ^ FinishTwowayBlockName;
							Problem_BlockMissing.LongDescription = "Block to replace with is missing in the current blockset.";
							Problem_BlockMissing.Solutions.add("Contact the authors of Challenge to add the block.");
							Problem_BlockMissing.Solutions.add("Add the block by yourself via block creator or macroblock.");
							Problem_BlockMissing.Solutions.add("Place a similar block that will function the same.");
							Problem_BlockMissing.Solutions.add("Wait before Nadeo will add the block.");
							Problem(Problem_BlockMissing);
						}
					}
				}
			}
		}
	}
	else {
		
	}
}
else {
	declare Start = StartLines[0];
	if(StartLines[0].IsItem) {
		declare SChProblem Problem_ItemStart;
		Problem_ItemStart.Name = "ITEM_START";
		Problem_ItemStart.Waypoint = Start;
		Problem_ItemStart.ShortDescription = "{{{{CANNOT_REPLACE_START}}}}";
		Problem_ItemStart.LongDescription = "Start is an item. Script can't replace those.";
		Problem_ItemStart.Solutions.add("Replace the start item manually with a possible finish variant.");
		Problem(Problem_ItemStart);
	}
	else {
		foreach(Relation, Relation_StartFinish[Environment]) {
			declare StartBlockName = Relation[0];
			declare FinishBlockName = Relation[1];

			if(Start.Block.Name == StartBlockName) {
				SetStatusProgress(.5);
				declare Removed = RemoveSpecificBlock(Start.Block);
				if(Removed) {
					declare Block = PlaceBlock(FinishBlockName, Start.Block.Coord, OppositeDirection(Start.Block.Direction));
					if(Block.Placed)
						SetStatusMessage(StartBlockName ^ " {{{{replaced_with}}}} " ^ FinishBlockName ^ ".");
					else {
						declare SChProblem Problem_BlockMissing;
						Problem_BlockMissing.Name = "BLOCK_MISSING";
						Problem_BlockMissing.BlockName = FinishBlockName;
						Problem_BlockMissing.ShortDescription = "{{{{BLOCK_MISSING}}}}: " ^ FinishBlockName;
						Problem_BlockMissing.LongDescription = "Block to replace with is missing in the current blockset.";
						Problem_BlockMissing.Solutions.add("Contact the authors of Challenge to add the block.");
						Problem_BlockMissing.Solutions.add("Add the block by yourself via block creator or macroblock.");
						Problem_BlockMissing.Solutions.add("Place a similar block that will function the same.");
						Problem_BlockMissing.Solutions.add("Wait before Nadeo will add the block.");
						Problem(Problem_BlockMissing);
					}
				}
			}
		}
	}
}

if(FinishLines.count == 1) {
	declare Finish = FinishLines[0];

	if(Finish.IsItem) {
		declare SChProblem Problem_ItemFinish;
		Problem_ItemFinish.Name = "ITEM_FINISH";
		Problem_ItemFinish.Waypoint = Finish;
		Problem_ItemFinish.ShortDescription = "{{{{CANNOT_REPLACE_FINISH}}}}";
		Problem_ItemFinish.LongDescription = "Finish is an item. Script can't replace those.";
		Problem_ItemFinish.Solutions.add("Replace the finish item manually with a possible start variant.");
		Problem(Problem_ItemFinish);
	}
	else {
		foreach(Relation, Relation_StartFinish[Environment]) {
			declare StartBlockName = Relation[0];
			declare FinishBlockName = Relation[1];
			
			if(Finish.Block.Name == FinishBlockName) {
				SetStatusProgress(1.);
				declare Removed = RemoveSpecificBlock(Finish.Block);
				if(Removed) {
					declare Block = PlaceBlock(StartBlockName, Finish.Block.Coord, OppositeDirection(Finish.Block.Direction));
					if(Block.Placed)
						SetStatusMessage(FinishBlockName ^ " {{{{replaced_with}}}} " ^ StartBlockName ^ ".");
					else {
						declare SChProblem Problem_BlockMissing;
						Problem_BlockMissing.Name = "BLOCK_MISSING";
						Problem_BlockMissing.BlockName = StartBlockName;
						Problem_BlockMissing.ShortDescription = "{{{{BLOCK_MISSING}}}}: " ^ StartBlockName;
						Problem_BlockMissing.LongDescription = "Block to replace with is missing in the current blockset.";
						Problem_BlockMissing.Solutions.add("Contact the authors of Challenge to add the block.");
						Problem_BlockMissing.Solutions.add("Add the block by yourself via block creator or macroblock.");
						Problem_BlockMissing.Solutions.add("Place a similar block that will function the same.");
						Problem_BlockMissing.Solutions.add("Wait before Nadeo will add the block.");
						Problem(Problem_BlockMissing);
					}
				}
			}
		}
	}
}
***

***Solver***
***
foreach(Problem,Problems) {

}
***